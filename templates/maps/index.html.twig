{% extends 'base.html.twig' %}

{% block title %}Bienvenue sur la map des utilisateurs !{% endblock %}

{% block body %}
{{ render(controller('App\\Controller\\NavbarController::navbar')) }}

<!-- User Map Filters -->
{% include 'components/_user_map_filters.html.twig' %}

<!-- Tag Filter Bar -->
{# {% include 'components/_tag_filter_bar.html.twig' with {
    tag_filter_context: 'user_map'
} %} #}

<!-- Le contenu des bulles est maintenant inclus via le template partiel complet -->
{% include 'maps/_bubbles.html.twig' %}

<script src="https://d3js.org/d3.v7.min.js"></script>
<script>
// Variables globales pour stocker les données des liens
let connectionData = {
    currentUserId: {{ current_user_id ?? 'null' }},
    friendIds: {{ friend_ids|json_encode|raw }},
    links: []
};

let simulation = null;

// Déplacer setBubbleZIndexHandlers dans le scope global
function setBubbleZIndexHandlers() {
    document.querySelectorAll('.bubble').forEach(bubble => {
        bubble.addEventListener('mouseenter', () => {
            bubble.style.zIndex = 9999;
        });
        bubble.addEventListener('mouseleave', () => {
            bubble.style.zIndex = '';
        });
        bubble.addEventListener('focus', () => {
            bubble.style.zIndex = 9999;
        });
        bubble.addEventListener('blur', () => {
            bubble.style.zIndex = '';
        });
    });
}

function renderBubbles() {
    const container = document.getElementById('bubble-container');
    const width = container.offsetWidth;
    const height = container.offsetHeight;
    const bubbles = document.querySelectorAll('.bubble');
    
    // Arrêter la simulation précédente si elle existe
    if (simulation) {
        simulation.stop();
    }
    
    // Calculer un rayon basé sur le nombre de bulles et la taille du conteneur
    const baseRadius = Math.min(width, height) * 0.3;
    const spacing = (2 * Math.PI) / bubbles.length;
    
    const nodes = Array.from(bubbles).map((el, i) => {
        const angle = i * spacing;
        const radius = baseRadius + (Math.random() * baseRadius * 0.3);
        
        // Position initiale aléatoire si pas déjà positionnée
        const currentLeft = parseFloat(el.style.left);
        const currentTop = parseFloat(el.style.top);
        
        return {
            id: parseInt(el.dataset.id),
            el: el,
            x: !isNaN(currentLeft) ? currentLeft + 40 : width / 2 + radius * Math.cos(angle),
            y: !isNaN(currentTop) ? currentTop + 40 : height / 2 + radius * Math.sin(angle),
            isFriend: connectionData.friendIds.includes(parseInt(el.dataset.id)),
            isCurrentUser: parseInt(el.dataset.id) === connectionData.currentUserId
        };
    });

    // Réinitialiser les liens
    connectionData.links = [];

    // Mettre à jour les données des liens
    updateConnectionData(nodes);

    simulation = d3.forceSimulation(nodes)
        .alpha(1)
        .alphaDecay(0.02)
        .velocityDecay(0.25)
        .force("x", d3.forceX(width / 2).strength(0.03))
        .force("y", d3.forceY(height / 2).strength(0.03))
        .force("charge", d3.forceManyBody().strength(-80))
        .force("collision", d3.forceCollide().radius(70).strength(0.8))
        .force("center", d3.forceCenter(width / 2, height / 2))
        .on("tick", () => {
            nodes.forEach(node => {
                node.x = Math.max(50, Math.min(width - 50, node.x));
                node.y = Math.max(50, Math.min(height - 50, node.y));
                
                if (node.el) {
                    node.el.style.left = (node.x - 40) + "px";
                    node.el.style.top = (node.y - 40) + "px";
                }
            });
            updateConnections(nodes);
        });

    function drag(simulation) {
        return d3.drag()
            .on("start", (event, d) => {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
                if (d.el) d.el.style.zIndex = 1000;
            })
            .on("drag", (event, d) => {
                d.fx = event.x;
                d.fy = event.y;
            })
            .on("end", (event, d) => {
                if (!event.active) simulation.alphaTarget(0);
                d.fx = null;
                d.fy = null;
                if (d.el) d.el.style.zIndex = '';
            });
    }

    d3.selectAll('.bubble').data(nodes).call(drag(simulation));
    
    // Initialiser les connexions
    initializeConnections();
    
    // Appliquer les gestionnaires d'événements pour les z-index
    setBubbleZIndexHandlers();
    
    setTimeout(() => {
        simulation.alpha(0.5).restart();
    }, 100);
}

function initializeConnections() {
    const svg = d3.select('#connection-lines');
    svg.selectAll('*').remove();
}

function updateConnectionData(nodes) {
    if (!connectionData.currentUserId) return;
    
    const currentUserNode = nodes.find(node => node.isCurrentUser);
    if (!currentUserNode) return;
    
    connectionData.links = nodes
        .filter(node => node.isFriend && !node.isCurrentUser && node.el)
        .map(friendNode => ({
            source: currentUserNode,
            target: friendNode
        }));
}

function updateConnections(nodes) {
    if (!connectionData.currentUserId) return;
    
    const svg = d3.select('#connection-lines');
    const lines = svg.selectAll('.connection-line')
        .data(connectionData.links);
    
    // Entrée
    lines.enter()
        .append('line')
        .attr('class', 'connection-line')
        .attr('stroke', '#3B82F6')
        .attr('stroke-width', 2)
        .attr('stroke-dasharray', '5,5')
        .attr('opacity', 0.6);
    
    // Mise à jour
    lines.attr('x1', d => {
        if (!d.source || typeof d.source.x !== 'number' || isNaN(d.source.x)) return 0;
        return d.source.x;
    })
    .attr('y1', d => {
        if (!d.source || typeof d.source.y !== 'number' || isNaN(d.source.y)) return 0;
        return d.source.y;
    })
    .attr('x2', d => {
        if (!d.target || typeof d.target.x !== 'number' || isNaN(d.target.x)) return 0;
        return d.target.x;
    })
    .attr('y2', d => {
        if (!d.target || typeof d.target.y !== 'number' || isNaN(d.target.y)) return 0;
        return d.target.y;
    });
    
    // Sortie
    lines.exit().remove();
}

function refreshConnections() {
    const bubbles = document.querySelectorAll('.bubble');
    const nodes = Array.from(bubbles).map(el => {
        const rect = el.getBoundingClientRect();
        const containerRect = document.getElementById('bubble-container').getBoundingClientRect();
        
        return {
            id: parseInt(el.dataset.id),
            el: el,
            x: rect.left - containerRect.left + 40,
            y: rect.top - containerRect.top + 40,
            isFriend: connectionData.friendIds.includes(parseInt(el.dataset.id)),
            isCurrentUser: parseInt(el.dataset.id) === connectionData.currentUserId
        };
    });
    
    updateConnectionData(nodes);
    updateConnections(nodes);
}

// Initialiser
renderBubbles();

// Permet de re-render les bulles après filtrage AJAX
window.renderUserBubbles = function() {
    renderBubbles();
};

window.refreshConnections = refreshConnections;
window.setBubbleZIndexHandlers = setBubbleZIndexHandlers;

// Initialiser les gestionnaires d'événements au chargement
document.addEventListener('DOMContentLoaded', function() {
    setBubbleZIndexHandlers();
});

window.addEventListener('resize', () => {
    refreshConnections();
});

// Fonction utilitaire pour créer conversation / ajouter au réseau et ouvrir la messagerie
function addToNetwork(userId) {
    fetch('/network/toggle/' + encodeURIComponent(userId), {
        method: 'POST',
        credentials: 'include',
        headers: {
            'X-Requested-With': 'XMLHttpRequest',
            'Content-Type': 'application/json',
            'Accept': 'application/json'
        },
        body: JSON.stringify({})
    })
    .then(r => r.text().then(text => ({ status: r.status, ok: r.ok, text })))
    .then(resp => {
        if (resp.status === 401) {
            window.location.href = '{{ path('app_login') }}';
            throw new Error('Unauthorized');
        }
        if (!resp.ok) {
            console.error('network/toggle error', resp.status, resp.text);
            alert('Erreur serveur (' + resp.status + '): ' + (resp.text || 'No details'));
            return;
        }
        let j = {};
        try { j = resp.text ? JSON.parse(resp.text) : {}; } catch (e) {
            console.warn('Réponse non JSON:', resp.text);
            alert('Réponse inattendue du serveur : ' + resp.text);
            return;
        }
        if (j.redirect) {
            window.location.href = j.redirect;
        } else if (j.conversationId) {
            window.location.href = '/private/conversation/' + j.conversationId;
        } else if (j.error) {
            alert('Erreur : ' + j.error);
        } else {
            // Mettre à jour la liste des amis
            if (connectionData.friendIds.includes(parseInt(userId))) {
                connectionData.friendIds = connectionData.friendIds.filter(id => id !== parseInt(userId));
            } else {
                connectionData.friendIds.push(parseInt(userId));
            }
            
            // Mettre à jour l'apparence de la bulle
            const bubble = document.querySelector(`.bubble[data-id="${userId}"]`);
            if (bubble) {
                if (connectionData.friendIds.includes(parseInt(userId))) {
                    bubble.classList.add('friend-bubble');
                    bubble.classList.remove('recommended-bubble');
                } else {
                    bubble.classList.remove('friend-bubble');
                    bubble.classList.add('recommended-bubble');
                }
            }
            
            refreshConnections();
        }
    })
    .catch(err => {
        if (err.message !== 'Unauthorized') {
            console.error('Fetch toggleNetwork failed:', err);
            alert('Erreur réseau lors de la création de la connexion. Voir console pour détails.');
        }
    });
}
</script>

<style>
.connection-line {
    transition: all 0.3s ease;
}

.current-user-bubble {
    border: 3px solid #3B82F6;
    box-shadow: 0 0 15px rgba(59, 130, 246, 0.4);
}

.friend-bubble {
    border: 3px solid #10B981;
    box-shadow: 0 0 15px rgba(16, 185, 129, 0.4);
}

.recommended-bubble {
    transition: border 0.3s ease, box-shadow 0.3s ease;
}
</style>
{% endblock %}